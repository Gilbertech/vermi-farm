// Msaidizi Insurance API Implementation
// This includes all the necessary backend APIs for the insurance application

const express = require('express');
const cors = require('cors');
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');

const app = express();
app.use(cors());
app.use(express.json());

// In-memory data store (replace with actual database in production)
let covers = [
  {
    id: 'IC001',
    userId: 'user123',
    farmLocation: 'Thika, Kiambu County',
    cropType: 'Maize',
    coverageAmount: 50000,
    premium: 2500,
    status: 'active',
    startDate: '2024-03-01',
    endDate: '2024-08-31',
    farmSize: 2,
    weatherTrigger: {
      rainfall: { min: 200, max: 800 },
      temperature: { min: 18, max: 28 }
    },
    createdAt: new Date('2024-03-01'),
    coordinates: { lat: -1.0332, lng: 37.0840 } // Thika coordinates
  }
];

let claims = [
  {
    id: 'CL001',
    coverId: 'IC001',
    userId: 'user123',
    amount: 15000,
    status: 'approved',
    submittedDate: '2024-07-15',
    weatherData: {
      rainfall: 150,
      temperature: 32,
      date: '2024-07-10'
    },
    payoutDate: '2024-07-20',
    triggerReason: 'Temperature exceeded maximum threshold (32°C > 28°C)',
    autoGenerated: true
  }
];

// Weather API integration (using OpenWeatherMap as example)
const WEATHER_API_KEY = process.env.WEATHER_API_KEY || 'your_openweather_api_key';

// Helper function to get coordinates from location
async function getCoordinates(location) {
  try {
    // Simple geocoding - in production, use proper geocoding service
    const locationMap = {
      'Thika, Kiambu County': { lat: -1.0332, lng: 37.0840 },
      'Nakuru': { lat: -0.3031, lng: 36.0800 },
      'Eldoret': { lat: 0.5143, lng: 35.2698 },
      'Kisumu': { lat: -0.0917, lng: 34.7680 }
    };
    
    return locationMap[location] || { lat: -1.0332, lng: 37.0840 };
  } catch (error) {
    console.error('Geocoding error:', error);
    return { lat: -1.0332, lng: 37.0840 }; // Default to Thika
  }
}

// Get current weather data
async function getCurrentWeather(lat, lng) {
  try {
    const response = await axios.get(
      `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${WEATHER_API_KEY}&units=metric`
    );
    
    return {
      temperature: Math.round(response.data.main.temp),
      humidity: response.data.main.humidity,
      rainfall: response.data.rain ? response.data.rain['1h'] || 0 : 0,
      windSpeed: Math.round(response.data.wind.speed * 3.6), // Convert m/s to km/h
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('Weather API error:', error);
    // Return mock data if API fails
    return {
      temperature: 24,
      humidity: 68,
      rainfall: 45,
      windSpeed: 12,
      timestamp: new Date().toISOString()
    };
  }
}

// Get weather forecast
async function getWeatherForecast(lat, lng) {
  try {
    const response = await axios.get(
      `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lng}&appid=${WEATHER_API_KEY}&units=metric`
    );
    
    return response.data.list.slice(0, 5).map(item => ({
      date: item.dt_txt.split(' ')[0],
      rainfall: item.rain ? item.rain['3h'] || 0 : 0,
      temperature: Math.round(item.main.temp),
      risk: calculateRisk(item.rain ? item.rain['3h'] || 0 : 0, item.main.temp)
    }));
  } catch (error) {
    console.error('Forecast API error:', error);
    // Return mock forecast if API fails
    return [
      { date: '2024-08-12', rainfall: 15, temperature: 26, risk: 'low' },
      { date: '2024-08-13', rainfall: 75, temperature: 22, risk: 'medium' },
      { date: '2024-08-14', rainfall: 120, temperature: 19, risk: 'high' }
    ];
  }
}

// Calculate risk level based on weather conditions
function calculateRisk(rainfall, temperature) {
  if (rainfall > 100 || temperature > 30 || temperature < 15) return 'high';
  if (rainfall > 50 || temperature > 28 || temperature < 18) return 'medium';
  return 'low';
}

// Calculate premium based on coverage amount, farm size, crop type, and location
function calculatePremium(coverageAmount, farmSize, cropType, location) {
  const basePremiumRate = 0.05; // 5% of coverage amount
  
  // Risk multipliers
  const cropRiskMultiplier = {
    'Maize': 1.0,
    'Beans': 1.2,
    'Tomatoes': 1.5,
    'Kale': 0.8,
    'Coffee': 1.3,
    'Tea': 0.9
  };
  
  const locationRiskMultiplier = {
    'Kiambu': 1.0,
    'Nakuru': 1.1,
    'Uasin Gishu': 1.2,
    'Kisumu': 1.3
  };
  
  const county = location.split(',').pop()?.trim() || 'Kiambu';
  const cropMultiplier = cropRiskMultiplier[cropType] || 1.0;
  const locationMultiplier = locationRiskMultiplier[county] || 1.0;
  const sizeMultiplier = Math.max(0.8, 1 - (farmSize * 0.05)); // Discount for larger farms
  
  return Math.round(coverageAmount * basePremiumRate * cropMultiplier * locationMultiplier * sizeMultiplier);
}

// API Routes

// 1. Get user's insurance covers
app.get('/api/covers/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const userCovers = covers.filter(cover => cover.userId === userId);
    
    // Add current weather data to active covers
    for (let cover of userCovers.filter(c => c.status === 'active')) {
      const weather = await getCurrentWeather(cover.coordinates.lat, cover.coordinates.lng);
      cover.currentWeather = weather;
    }
    
    res.json({
      success: true,
      data: userCovers
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to fetch covers'
    });
  }
});

// 2. Create new insurance cover
app.post('/api/covers', async (req, res) => {
  try {
    const {
      userId,
      farmLocation,
      cropType,
      coverageAmount,
      farmSize,
      startDate,
      endDate,
      weatherTrigger
    } = req.body;

    // Validate required fields
    if (!userId || !farmLocation || !cropType || !coverageAmount || !farmSize) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields'
      });
    }

    // Get coordinates for the farm location
    const coordinates = await getCoordinates(farmLocation);
    
    // Calculate premium
    const premium = calculatePremium(coverageAmount, farmSize, cropType, farmLocation);
    
    // Set default weather triggers if not provided
    const defaultTriggers = {
      rainfall: { min: 200, max: 800 },
      temperature: { min: 18, max: 28 }
    };

    const newCover = {
      id: `IC${String(covers.length + 1).padStart(3, '0')}`,
      userId,
      farmLocation,
      cropType,
      coverageAmount: Number(coverageAmount),
      farmSize: Number(farmSize),
      premium,
      status: 'pending', // Starts as pending, becomes active after payment
      startDate: startDate || new Date().toISOString().split('T')[0],
      endDate: endDate || new Date(Date.now() + 180 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 6 months default
      weatherTrigger: weatherTrigger || defaultTriggers,
      coordinates,
      createdAt: new Date()
    };

    covers.push(newCover);

    res.status(201).json({
      success: true,
      data: newCover,
      message: 'Insurance cover created successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to create cover'
    });
  }
});

// 3. Calculate premium (for quote purposes)
app.post('/api/covers/calculate-premium', async (req, res) => {
  try {
    const { coverageAmount, farmSize, cropType, farmLocation } = req.body;
    
    if (!coverageAmount || !farmSize || !cropType || !farmLocation) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields for premium calculation'
      });
    }

    const premium = calculatePremium(coverageAmount, farmSize, cropType, farmLocation);
    
    res.json({
      success: true,
      data: {
        premium,
        coverageAmount,
        premiumRate: ((premium / coverageAmount) * 100).toFixed(2) + '%'
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to calculate premium'
    });
  }
});

// 4. Get user's claims
app.get('/api/claims/:userId', (req, res) => {
  try {
    const { userId } = req.params;
    const userClaims = claims.filter(claim => claim.userId === userId);
    
    res.json({
      success: true,
      data: userClaims
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to fetch claims'
    });
  }
});

// 5. Process automatic weather claims (background job)
app.post('/api/claims/process-weather-triggers', async (req, res) => {
  try {
    const activeCovers = covers.filter(cover => 
      cover.status === 'active' && new Date(cover.endDate) > new Date()
    );

    const newClaims = [];

    for (let cover of activeCovers) {
      const weather = await getCurrentWeather(cover.coordinates.lat, cover.coordinates.lng);
      
      // Check if weather conditions trigger a claim
      const triggers = cover.weatherTrigger;
      let triggerReason = null;
      let payoutAmount = 0;

      if (weather.rainfall < triggers.rainfall.min) {
        triggerReason = `Drought conditions: ${weather.rainfall}mm rainfall below minimum threshold (${triggers.rainfall.min}mm)`;
        payoutAmount = cover.coverageAmount * 0.3; // 30% payout for drought
      } else if (weather.rainfall > triggers.rainfall.max) {
        triggerReason = `Excessive rainfall: ${weather.rainfall}mm above maximum threshold (${triggers.rainfall.max}mm)`;
        payoutAmount = cover.coverageAmount * 0.4; // 40% payout for floods
      } else if (weather.temperature < triggers.temperature.min) {
        triggerReason = `Cold damage: ${weather.temperature}°C below minimum threshold (${triggers.temperature.min}°C)`;
        payoutAmount = cover.coverageAmount * 0.25; // 25% payout for cold
      } else if (weather.temperature > triggers.temperature.max) {
        triggerReason = `Heat stress: ${weather.temperature}°C above maximum threshold (${triggers.temperature.max}°C)`;
        payoutAmount = cover.coverageAmount * 0.35; // 35% payout for heat
      }

      if (triggerReason) {
        // Check if claim already exists for today
        const today = new Date().toISOString().split('T')[0];
        const existingClaim = claims.find(claim => 
          claim.coverId === cover.id && 
          claim.weatherData.date === today
        );

        if (!existingClaim) {
          const newClaim = {
            id: `CL${String(claims.length + 1).padStart(3, '0')}`,
            coverId: cover.id,
            userId: cover.userId,
            amount: Math.round(payoutAmount),
            status: 'approved', // Auto-approved for weather triggers
            submittedDate: today,
            weatherData: {
              rainfall: weather.rainfall,
              temperature: weather.temperature,
              date: today
            },
            triggerReason,
            autoGenerated: true,
            payoutDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] // 2 days from now
          };

          claims.push(newClaim);
          newClaims.push(newClaim);
        }
      }
    }

    res.json({
      success: true,
      data: {
        processedCovers: activeCovers.length,
        newClaims: newClaims.length,
        claims: newClaims
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to process weather triggers'
    });
  }
});

// 6. Get weather data for a specific location
app.get('/api/weather/:location', async (req, res) => {
  try {
    const { location } = req.params;
    const coordinates = await getCoordinates(location);
    
    const [currentWeather, forecast] = await Promise.all([
      getCurrentWeather(coordinates.lat, coordinates.lng),
      getWeatherForecast(coordinates.lat, coordinates.lng)
    ]);

    res.json({
      success: true,
      data: {
        current: currentWeather,
        forecast,
        location,
        coordinates
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to fetch weather data'
    });
  }
});

// 7. Update cover status (e.g., activate after payment)
app.patch('/api/covers/:coverId', (req, res) => {
  try {
    const { coverId } = req.params;
    const { status, paymentReference } = req.body;

    const coverIndex = covers.findIndex(cover => cover.id === coverId);
    
    if (coverIndex === -1) {
      return res.status(404).json({
        success: false,
        error: 'Cover not found'
      });
    }

    covers[coverIndex] = {
      ...covers[coverIndex],
      status,
      ...(paymentReference && { paymentReference }),
      updatedAt: new Date()
    };

    res.json({
      success: true,
      data: covers[coverIndex],
      message: 'Cover updated successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to update cover'
    });
  }
});

// 8. Get claim details
app.get('/api/claims/detail/:claimId', (req, res) => {
  try {
    const { claimId } = req.params;
    const claim = claims.find(c => c.id === claimId);
    
    if (!claim) {
      return res.status(404).json({
        success: false,
        error: 'Claim not found'
      });
    }

    // Get associated cover details
    const cover = covers.find(c => c.id === claim.coverId);

    res.json({
      success: true,
      data: {
        ...claim,
        cover
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to fetch claim details'
    });
  }
});

// 9. Manual claim submission (for edge cases)
app.post('/api/claims', async (req, res) => {
  try {
    const {
      userId,
      coverId,
      reason,
      description,
      supportingDocuments
    } = req.body;

    // Validate cover exists and is active
    const cover = covers.find(c => c.id === coverId && c.userId === userId);
    if (!cover) {
      return res.status(404).json({
        success: false,
        error: 'Cover not found or not authorized'
      });
    }

    if (cover.status !== 'active') {
      return res.status(400).json({
        success: false,
        error: 'Cover is not active'
      });
    }

    // Get current weather for context
    const weather = await getCurrentWeather(cover.coordinates.lat, cover.coordinates.lng);

    const newClaim = {
      id: `CL${String(claims.length + 1).padStart(3, '0')}`,
      coverId,
      userId,
      amount: 0, // To be determined during review
      status: 'pending',
      submittedDate: new Date().toISOString().split('T')[0],
      reason,
      description,
      supportingDocuments: supportingDocuments || [],
      weatherData: {
        rainfall: weather.rainfall,
        temperature: weather.temperature,
        date: new Date().toISOString().split('T')[0]
      },
      autoGenerated: false
    };

    claims.push(newClaim);

    res.status(201).json({
      success: true,
      data: newClaim,
      message: 'Claim submitted successfully for review'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to submit claim'
    });
  }
});

// 10. Get dashboard summary for user
app.get('/api/dashboard/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    
    const userCovers = covers.filter(cover => cover.userId === userId);
    const userClaims = claims.filter(claim => claim.userId === userId);
    
    const totalCoverage = userCovers.reduce((sum, cover) => sum + cover.coverageAmount, 0);
    const totalPaid = userClaims
      .filter(claim => claim.status === 'paid')
      .reduce((sum, claim) => sum + claim.amount, 0);
    
    const activeCover = userCovers.find(cover => cover.status === 'active');
    let weatherRisk = 'low';
    
    if (activeCover) {
      const weather = await getCurrentWeather(activeCover.coordinates.lat, activeCover.coordinates.lng);
      weatherRisk = calculateRisk(weather.rainfall, weather.temperature);
    }

    res.json({
      success: true,
      data: {
        summary: {
          activeCovers: userCovers.filter(c => c.status === 'active').length,
          totalCoverage,
          totalClaims: userClaims.length,
          totalPaid,
          weatherRisk
        },
        covers: userCovers,
        recentClaims: userClaims.slice(-5) // Last 5 claims
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to fetch dashboard data'
    });
  }
});

// 11. Payment processing integration
app.post('/api/covers/:coverId/pay', async (req, res) => {
  try {
    const { coverId } = req.params;
    const { phoneNumber, amount } = req.body;

    const cover = covers.find(c => c.id === coverId);
    if (!cover) {
      return res.status(404).json({
        success: false,
        error: 'Cover not found'
      });
    }

    // Mock M-Pesa STK push integration
    const paymentReference = `PAY${Date.now()}`;
    
    // In production, integrate with actual payment gateway
    // For now, simulate successful payment
    setTimeout(() => {
      const coverIndex = covers.findIndex(c => c.id === coverId);
      covers[coverIndex].status = 'active';
      covers[coverIndex].paymentReference = paymentReference;
    }, 2000);

    res.json({
      success: true,
      data: {
        paymentReference,
        amount,
        phoneNumber,
        message: 'Payment initiated. You will receive an M-Pesa prompt shortly.'
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Payment processing failed'
    });
  }
});

// 12. Get weather forecast for multiple locations
app.post('/api/weather/forecast', async (req, res) => {
  try {
    const { locations } = req.body;
    
    const forecasts = await Promise.all(
      locations.map(async (location) => {
        const coordinates = await getCoordinates(location);
        const forecast = await getWeatherForecast(coordinates.lat, coordinates.lng);
        return {
          location,
          forecast
        };
      })
    );

    res.json({
      success: true,
      data: forecasts
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to fetch weather forecasts'
    });
  }
});

// 13. Webhook for weather alerts
app.post('/api/webhooks/weather-alert', async (req, res) => {
  try {
    const { location, severity, weatherData } = req.body;
    
    // Find covers in the affected location
    const affectedCovers = covers.filter(cover => 
      cover.farmLocation.includes(location) && cover.status === 'active'
    );

    // Send notifications to affected users
    const notifications = affectedCovers.map(cover => ({
      userId: cover.userId,
      coverId: cover.id,
      type: 'weather_alert',
      severity,
      message: `Weather alert for ${cover.farmLocation}: ${severity} risk conditions detected`,
      weatherData,
      timestamp: new Date()
    }));

    // In production, save notifications and send via SMS/email
    console.log('Weather alert notifications:', notifications);

    res.json({
      success: true,
      data: {
        affectedCovers: affectedCovers.length,
        notifications: notifications.length
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to process weather alert'
    });
  }
});

// 14. Admin: Get all claims for processing
app.get('/api/admin/claims', (req, res) => {
  try {
    const { status, limit = 50, offset = 0 } = req.query;
    
    let filteredClaims = claims;
    if (status) {
      filteredClaims = claims.filter(claim => claim.status === status);
    }

    const paginatedClaims = filteredClaims
      .slice(Number(offset), Number(offset) + Number(limit))
      .map(claim => ({
        ...claim,
        cover: covers.find(c => c.id === claim.coverId)
      }));

    res.json({
      success: true,
      data: paginatedClaims,
      pagination: {
        total: filteredClaims.length,
        limit: Number(limit),
        offset: Number(offset)
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to fetch claims'
    });
  }
});

// 15. Admin: Update claim status
app.patch('/api/admin/claims/:claimId', (req, res) => {
  try {
    const { claimId } = req.params;
    const { status, amount, notes } = req.body;

    const claimIndex = claims.findIndex(claim => claim.id === claimId);
    
    if (claimIndex === -1) {
      return res.status(404).json({
        success: false,
        error: 'Claim not found'
      });
    }

    claims[claimIndex] = {
      ...claims[claimIndex],
      status,
      ...(amount && { amount: Number(amount) }),
      ...(notes && { adminNotes: notes }),
      ...(status === 'paid' && { payoutDate: new Date().toISOString().split('T')[0] }),
      updatedAt: new Date()
    };

    res.json({
      success: true,
      data: claims[claimIndex],
      message: 'Claim updated successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to update claim'
    });
  }
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('API Error:', error);
  res.status(500).json({
    success: false,
    error: 'Internal server error'
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    error: 'API endpoint not found'
  });
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Msaidizi Insurance API server running on port ${PORT}`);
});

// Export for testing or integration
module.exports = app;

// Additional utility functions for integration

// Background job to check weather triggers (run every hour)
function startWeatherMonitoring() {
  setInterval(async () => {
    try {
      const response = await axios.post('http://localhost:3001/api/claims/process-weather-triggers');
      console.log('Weather monitoring check completed:', response.data);
    } catch (error) {
      console.error('Weather monitoring error:', error.message);
    }
  }, 60 * 60 * 1000); // Run every hour
}

// Start background monitoring if this is the main module
if (require.main === module) {
  startWeatherMonitoring();
}
export default Msaidizi-insurance;

/* 
API ENDPOINT SUMMARY:

1. GET /api/covers/:userId - Get user's insurance covers
2. POST /api/covers - Create new insurance cover
3. POST /api/covers/calculate-premium - Calculate premium quote
4. GET /api/claims/:userId - Get user's claims
5. POST /api/claims/process-weather-triggers - Process automatic weather claims
6. GET /api/weather/:location - Get weather data for location
7. PATCH /api/covers/:coverId - Update cover status
8. GET /api/claims/detail/:claimId - Get claim details
9. POST /api/claims - Submit manual claim
10. POST /api/covers/:coverId/pay - Process payment
11. POST /api/weather/forecast - Get forecast for multiple locations
12. POST /api/webhooks/weather-alert - Receive weather alerts
13. GET /api/admin/claims - Admin: Get all claims
14. PATCH /api/admin/claims/:claimId - Admin: Update claim status
15. GET /api/dashboard/:userId - Get user dashboard summary

ENVIRONMENT VARIABLES NEEDED:
- WEATHER_API_KEY: OpenWeatherMap API key
- PORT: Server port (default: 3001)
- DATABASE_URL: Database connection string (if using real database)
- MPESA_CONSUMER_KEY: M-Pesa API credentials
- MPESA_CONSUMER_SECRET: M-Pesa API credentials

DEPENDENCIES TO INSTALL:
npm install express cors axios uuid

INTEGRATION NOTES:
1. Replace in-memory storage with actual database (MongoDB, PostgreSQL, etc.)
2. Integrate with real payment gateway (M-Pesa, Flutterwave, etc.)
3. Set up proper weather API credentials
4. Implement proper authentication and authorization
5. Add input validation and sanitization
6. Set up logging and monitoring
7. Add rate limiting for API endpoints
8. Implement proper error handling and user notifications
9. Set up background job scheduler (cron jobs or queue system)
10. Add API documentation (Swagger/OpenAPI)
*/