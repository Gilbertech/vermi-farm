// MsaidiziInsuranceService.ts
// Frontend service layer for Msaidizi Insurance API integration

import axios, { AxiosResponse, AxiosError } from 'axios';

// API Configuration
const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';
const API_TIMEOUT = 10000; // 10 seconds

// Create axios instance with default configuration
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: API_TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Types and Interfaces
export interface InsuranceCover {
  id: string;
  userId: string;
  farmLocation: string;
  cropType: string;
  coverageAmount: number;
  premium: number;
  status: 'active' | 'pending' | 'expired';
  startDate: string;
  endDate: string;
  farmSize: number;
  weatherTrigger: {
    rainfall: { min: number; max: number };
    temperature: { min: number; max: number };
  };
  coordinates: { lat: number; lng: number };
  createdAt: string;
  currentWeather?: WeatherData;
  paymentReference?: string;
}

export interface Claim {
  id: string;
  coverId: string;
  userId: string;
  amount: number;
  status: 'pending' | 'approved' | 'paid' | 'rejected';
  submittedDate: string;
  weatherData: {
    rainfall: number;
    temperature: number;
    date: string;
  };
  payoutDate?: string;
  triggerReason?: string;
  autoGenerated: boolean;
  reason?: string;
  description?: string;
  adminNotes?: string;
}

export interface WeatherData {
  temperature: number;
  humidity: number;
  rainfall: number;
  windSpeed: number;
  timestamp: string;
}

export interface WeatherForecast {
  date: string;
  rainfall: number;
  temperature: number;
  risk: 'low' | 'medium' | 'high';
}

export interface PremiumCalculation {
  premium: number;
  coverageAmount: number;
  premiumRate: string;
}

export interface DashboardSummary {
  summary: {
    activeCovers: number;
    totalCoverage: number;
    totalClaims: number;
    totalPaid: number;
    weatherRisk: 'low' | 'medium' | 'high';
  };
  covers: InsuranceCover[];
  recentClaims: Claim[];
}

export interface CreateCoverRequest {
  userId: string;
  farmLocation: string;
  cropType: string;
  coverageAmount: number;
  farmSize: number;
  startDate?: string;
  endDate?: string;
  weatherTrigger?: {
    rainfall: { min: number; max: number };
    temperature: { min: number; max: number };
  };
}

export interface PaymentRequest {
  phoneNumber: string;
  amount: number;
}

export interface APIResponse<T> {
  success: boolean;
  data: T;
  message?: string;
  error?: string;
}

// API Response interceptor for error handling
apiClient.interceptors.response.use(
  (response: AxiosResponse) => response,
  (error: AxiosError) => {
    console.error('API Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

// MsaidiziInsuranceService Class
export class MsaidiziInsuranceService {
  private static instance: MsaidiziInsuranceService;

  // Singleton pattern
  public static getInstance(): MsaidiziInsuranceService {
    if (!MsaidiziInsuranceService.instance) {
      MsaidiziInsuranceService.instance = new MsaidiziInsuranceService();
    }
    return MsaidiziInsuranceService.instance;
  }

  // Insurance Cover Management Methods

  /**
   * Get all insurance covers for a specific user
   */
  async getUserCovers(userId: string): Promise<InsuranceCover[]> {
    try {
      const response = await apiClient.get<APIResponse<InsuranceCover[]>>(`/covers/${userId}`);
      return response.data.data;
    } catch (error) {
      console.error('Error fetching user covers:', error);
      throw new Error('Failed to fetch insurance covers');
    }
  }

  /**
   * Create a new insurance cover
   */
  async createCover(coverData: CreateCoverRequest): Promise<InsuranceCover> {
    try {
      const response = await apiClient.post<APIResponse<InsuranceCover>>('/covers', coverData);
      return response.data.data;
    } catch (error) {
      console.error('Error creating cover:', error);
      throw new Error('Failed to create insurance cover');
    }
  }

  /**
   * Calculate premium for insurance cover
   */
  async calculatePremium(
    coverageAmount: number,
    farmSize: number,
    cropType: string,
    farmLocation: string
  ): Promise<PremiumCalculation> {
    try {
      const response = await apiClient.post<APIResponse<PremiumCalculation>>('/covers/calculate-premium', {
        coverageAmount,
        farmSize,
        cropType,
        farmLocation,
      });
      return response.data.data;
    } catch (error) {
      console.error('Error calculating premium:', error);
      throw new Error('Failed to calculate premium');
    }
  }

  /**
   * Update cover status (e.g., activate after payment)
   */
  async updateCoverStatus(
    coverId: string,
    status: string,
    paymentReference?: string
  ): Promise<InsuranceCover> {
    try {
      const response = await apiClient.patch<APIResponse<InsuranceCover>>(`/covers/${coverId}`, {
        status,
        paymentReference,
      });
      return response.data.data;
    } catch (error) {
      console.error('Error updating cover status:', error);
      throw new Error('Failed to update cover status');
    }
  }

  // Claims Management Methods

  /**
   * Get all claims for a specific user
   */
  async getUserClaims(userId: string): Promise<Claim[]> {
    try {
      const response = await apiClient.get<APIResponse<Claim[]>>(`/claims/${userId}`);
      return response.data.data;
    } catch (error) {
      console.error('Error fetching user claims:', error);
      throw new Error('Failed to fetch claims');
    }
  }

  /**
   * Get detailed information about a specific claim
   */
  async getClaimDetails(claimId: string): Promise<Claim & { cover: InsuranceCover }> {
    try {
      const response = await apiClient.get<APIResponse<Claim & { cover: InsuranceCover }>>(
        `/claims/detail/${claimId}`
      );
      return response.data.data;
    } catch (error) {
      console.error('Error fetching claim details:', error);
      throw new Error('Failed to fetch claim details');
    }
  }

  /**
   * Submit a manual claim
   */
  async submitClaim(
    userId: string,
    coverId: string,
    reason: string,
    description: string,
    supportingDocuments?: string[]
  ): Promise<Claim> {
    try {
      const response = await apiClient.post<APIResponse<Claim>>('/claims', {
        userId,
        coverId,
        reason,
        description,
        supportingDocuments,
      });
      return response.data.data;
    } catch (error) {
      console.error('Error submitting claim:', error);
      throw new Error('Failed to submit claim');
    }
  }

  /**
   * Process automatic weather triggers (admin function)
   */
  async processWeatherTriggers(): Promise<{
    processedCovers: number;
    newClaims: number;
    claims: Claim[];
  }> {
    try {
      const response = await apiClient.post<
        APIResponse<{ processedCovers: number; newClaims: number; claims: Claim[] }>
      >('/claims/process-weather-triggers');
      return response.data.data;
    } catch (error) {
      console.error('Error processing weather triggers:', error);
      throw new Error('Failed to process weather triggers');
    }
  }

  // Weather Data Methods

  /**
   * Get current weather and forecast for a location
   */
  async getWeatherData(location: string): Promise<{
    current: WeatherData;
    forecast: WeatherForecast[];
    location: string;
    coordinates: { lat: number; lng: number };
  }> {
    try {
      const response = await apiClient.get<
        APIResponse<{
          current: WeatherData;
          forecast: WeatherForecast[];
          location: string;
          coordinates: { lat: number; lng: number };
        }>
      >(`/weather/${encodeURIComponent(location)}`);
      return response.data.data;
    } catch (error) {
      console.error('Error fetching weather data:', error);
      throw new Error('Failed to fetch weather data');
    }
  }

  /**
   * Get weather forecast for multiple locations
   */
  async getMultiLocationForecast(locations: string[]): Promise<{
    location: string;
    forecast: WeatherForecast[];
  }[]> {
    try {
      const response = await apiClient.post<
        APIResponse<{ location: string; forecast: WeatherForecast[] }[]>
      >('/weather/forecast', { locations });
      return response.data.data;
    } catch (error) {
      console.error('Error fetching multi-location forecast:', error);
      throw new Error('Failed to fetch weather forecasts');
    }
  }

  // Payment Methods

  /**
   * Process payment for insurance cover
   */
  async processPayment(coverId: string, paymentData: PaymentRequest): Promise<{
    paymentReference: string;
    amount: number;
    phoneNumber: string;
    message: string;
  }> {
    try {
      const response = await apiClient.post<
        APIResponse<{
          paymentReference: string;
          amount: number;
          phoneNumber: string;
          message: string;
        }>
      >(`/covers/${coverId}/pay`, paymentData);
      return response.data.data;
    } catch (error) {
      console.error('Error processing payment:', error);
      throw new Error('Failed to process payment');
    }
  }

  // Dashboard Methods

  /**
   * Get dashboard summary for user
   */
  async getDashboardSummary(userId: string): Promise<DashboardSummary> {
    try {
      const response = await apiClient.get<APIResponse<DashboardSummary>>(`/dashboard/${userId}`);
      return response.data.data;
    } catch (error) {
      console.error('Error fetching dashboard summary:', error);
      throw new Error('Failed to fetch dashboard summary');
    }
  }

  // Utility Methods

  /**
   * Get available crop types
   */
  getCropTypes(): string[] {
    return ['Maize', 'Beans', 'Tomatoes', 'Kale', 'Coffee', 'Tea', 'Potatoes', 'Bananas'];
  }

  /**
   * Get available Kenyan counties
   */
  getCounties(): string[] {
    return [
      'Baringo', 'Bomet', 'Bungoma', 'Busia', 'Elgeyo-Marakwet', 'Embu', 'Garissa', 'Homa Bay',
      'Isiolo', 'Kajiado', 'Kakamega', 'Kericho', 'Kiambu', 'Kilifi', 'Kirinyaga', 'Kisii',
      'Kisumu', 'Kitui', 'Kwale', 'Laikipia', 'Lamu', 'Machakos', 'Makueni', 'Mandera',
      'Marsabit', 'Meru', 'Migori', 'Mombasa', 'Murang\'a', 'Nairobi', 'Nakuru', 'Nandi',
      'Narok', 'Nyamira', 'Nyandarua', 'Nyeri', 'Samburu', 'Siaya', 'Taita-Taveta', 'Tana River',
      'Tharaka-Nithi', 'Trans Nzoia', 'Turkana', 'Uasin Gishu', 'Vihiga', 'Wajir', 'West Pokot'
    ];
  }

  /**
   * Format currency in KES
   */
  formatCurrency(amount: number): string {
    return `KES ${amount.toLocaleString()}`;
  }

  /**
   * Calculate coverage period in days
   */
  calculateCoverageDays(startDate: string, endDate: string): number {
    const start = new Date(startDate);
    const end = new Date(endDate);
    return Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
  }

  /**
   * Get risk level color for UI
   */
  getRiskColor(risk: 'low' | 'medium' | 'high'): string {
    switch (risk) {
      case 'low':
        return 'green';
      case 'medium':
        return 'yellow';
      case 'high':
        return 'red';
      default:
        return 'gray';
    }
  }

  /**
   * Get status color for UI
   */
  getStatusColor(status: string): string {
    switch (status.toLowerCase()) {
      case 'active':
        return 'green';
      case 'pending':
        return 'yellow';
      case 'expired':
        return 'gray';
      case 'approved':
        return 'blue';
      case 'paid':
        return 'green';
      case 'rejected':
        return 'red';
      default:
        return 'gray';
    }
  }

  /**
   * Validate phone number (Kenyan format)
   */
  validatePhoneNumber(phoneNumber: string): boolean {
    const kenyanPhoneRegex = /^(\+254|0)[17]\d{8}$/;
    return kenyanPhoneRegex.test(phoneNumber);
  }

  /**
   * Format phone number to Kenyan standard
   */
  formatPhoneNumber(phoneNumber: string): string {
    // Remove any spaces or special characters
    const cleanNumber = phoneNumber.replace(/\s+/g, '').replace(/[^\d+]/g, '');
    
    // Convert to +254 format
    if (cleanNumber.startsWith('0')) {
      return `+254${cleanNumber.substring(1)}`;
    } else if (cleanNumber.startsWith('254')) {
      return `+${cleanNumber}`;
    } else if (cleanNumber.startsWith('+254')) {
      return cleanNumber;
    }
    
    return phoneNumber; // Return original if format is unclear
  }

  /**
   * Calculate days until coverage expires
   */
  getDaysToExpiry(endDate: string): number {
    const today = new Date();
    const expiry = new Date(endDate);
    return Math.ceil((expiry.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
  }

  /**
   * Check if coverage is expiring soon (within 30 days)
   */
  isCoverageExpiringSoon(endDate: string): boolean {
    return this.getDaysToExpiry(endDate) <= 30;
  }

  /**
   * Get weather condition description
   */
  getWeatherDescription(temperature: number, rainfall: number): string {
    if (temperature > 30) {
      return 'Very hot conditions - potential heat stress risk';
    } else if (temperature < 15) {
      return 'Cold conditions - potential frost risk';
    } else if (rainfall > 100) {
      return 'Heavy rainfall - potential flooding risk';
    } else if (rainfall < 10) {
      return 'Dry conditions - potential drought risk';
    } else {
      return 'Normal weather conditions';
    }
  }

  /**
   * Generate weather alert message
   */
  generateWeatherAlert(
    cover: InsuranceCover,
    currentWeather: WeatherData
  ): string | null {
    const { weatherTrigger } = cover;
    
    if (currentWeather.rainfall < weatherTrigger.rainfall.min) {
      return `Drought alert: Rainfall (${currentWeather.rainfall}mm) below minimum threshold (${weatherTrigger.rainfall.min}mm)`;
    }
    
    if (currentWeather.rainfall > weatherTrigger.rainfall.max) {
      return `Flood alert: Rainfall (${currentWeather.rainfall}mm) above maximum threshold (${weatherTrigger.rainfall.max}mm)`;
    }
    
    if (currentWeather.temperature < weatherTrigger.temperature.min) {
      return `Cold alert: Temperature (${currentWeather.temperature}°C) below minimum threshold (${weatherTrigger.temperature.min}°C)`;
    }
    
    if (currentWeather.temperature > weatherTrigger.temperature.max) {
      return `Heat alert: Temperature (${currentWeather.temperature}°C) above maximum threshold (${weatherTrigger.temperature.max}°C)`;
    }
    
    return null; // No alert needed
  }

  /**
   * Error handling wrapper for API calls
   */
  private async handleApiCall<T>(apiCall: () => Promise<T>): Promise<T> {
    try {
      return await apiCall();
    } catch (error) {
      if (axios.isAxiosError(error)) {
        const message = error.response?.data?.error || error.message;
        throw new Error(`API Error: ${message}`);
      }
      throw error;
    }
  }
}

// Export singleton instance
export const msaidiziInsuranceService = MsaidiziInsuranceService.getInstance();

// Export default
export default msaidiziInsuranceService;

// Additional utility functions for React components

/**
 * Custom hook for managing insurance covers
 */
export const useInsuranceCovers = (userId: string) => {
  const [covers, setCovers] = React.useState<InsuranceCover[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    const fetchCovers = async () => {
      try {
        setLoading(true);
        const userCovers = await msaidiziInsuranceService.getUserCovers(userId);
        setCovers(userCovers);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch covers');
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchCovers();
    }
  }, [userId]);

  const refreshCovers = async () => {
    try {
      const userCovers = await msaidiziInsuranceService.getUserCovers(userId);
      setCovers(userCovers);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to refresh covers');
    }
  };

  return { covers, loading, error, refreshCovers };
};

/**
 * Custom hook for managing claims
 */
export const useClaims = (userId: string) => {
  const [claims, setClaims] = React.useState<Claim[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    const fetchClaims = async () => {
      try {
        setLoading(true);
        const userClaims = await msaidiziInsuranceService.getUserClaims(userId);
        setClaims(userClaims);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch claims');
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchClaims();
    }
  }, [userId]);

  const refreshClaims = async () => {
    try {
      const userClaims = await msaidiziInsuranceService.getUserClaims(userId);
      setClaims(userClaims);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to refresh claims');
    }
  };

  return { claims, loading, error, refreshClaims };
};

/**
 * Custom hook for weather data
 */
export const useWeatherData = (location: string) => {
  const [weatherData, setWeatherData] = React.useState<{
    current: WeatherData;
    forecast: WeatherForecast[];
  } | null>(null);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    const fetchWeatherData = async () => {
      try {
        setLoading(true);
        const data = await msaidiziInsuranceService.getWeatherData(location);
        setWeatherData({ current: data.current, forecast: data.forecast });
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch weather data');
      } finally {
        setLoading(false);
      }
    };

    if (location) {
      fetchWeatherData();
    }
  }, [location]);

  return { weatherData, loading, error };
};